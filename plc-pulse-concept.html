<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>PLC — The Pulse of Civilization</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@300;400;500&family=Instrument+Serif:ital@0;1&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  :root {
    --pulse-core: #ff3a2f;
    --pulse-mid: #ff6b35;
    --pulse-outer: #1a3a5c;
    --grid-line: rgba(255, 58, 47, 0.06);
    --text-primary: #e8e4df;
    --text-secondary: rgba(232, 228, 223, 0.5);
    --bg: #07080a;
  }

  html, body {
    width: 100%; height: 100%;
    background: var(--bg);
    color: var(--text-primary);
    font-family: 'IBM Plex Mono', monospace;
    overflow: hidden;
    cursor: crosshair;
  }

  canvas {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
  }

  .overlay {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    pointer-events: none;
    z-index: 10;
  }

  .title-block {
    position: absolute;
    bottom: 80px;
    left: 60px;
  }

  .title-block h1 {
    font-family: 'Instrument Serif', serif;
    font-size: clamp(42px, 6vw, 96px);
    font-weight: 400;
    line-height: 0.95;
    letter-spacing: -0.03em;
    color: var(--text-primary);
    opacity: 0;
    animation: fadeUp 1.8s cubic-bezier(0.16, 1, 0.3, 1) 0.5s forwards;
  }

  .title-block h1 em {
    font-style: italic;
    color: var(--pulse-core);
  }

  .subtitle {
    font-family: 'IBM Plex Mono', monospace;
    font-size: 11px;
    font-weight: 300;
    letter-spacing: 0.15em;
    text-transform: uppercase;
    color: var(--text-secondary);
    margin-top: 20px;
    opacity: 0;
    animation: fadeUp 1.8s cubic-bezier(0.16, 1, 0.3, 1) 0.9s forwards;
  }

  .corner-label {
    position: absolute;
    font-size: 10px;
    font-weight: 400;
    letter-spacing: 0.2em;
    text-transform: uppercase;
    color: var(--text-secondary);
  }

  .corner-label.tl { top: 30px; left: 60px; }
  .corner-label.tr { top: 30px; right: 60px; }
  .corner-label.br { bottom: 30px; right: 60px; }

  .scan-counter {
    position: absolute;
    top: 30px;
    right: 60px;
    font-size: 10px;
    font-weight: 300;
    letter-spacing: 0.15em;
    color: var(--text-secondary);
    font-variant-numeric: tabular-nums;
  }

  .industry-labels {
    position: absolute;
    top: 50%;
    right: 60px;
    transform: translateY(-50%);
    display: flex;
    flex-direction: column;
    gap: 6px;
    opacity: 0;
    animation: fadeUp 1.8s cubic-bezier(0.16, 1, 0.3, 1) 1.4s forwards;
  }

  .industry-label {
    font-size: 9px;
    font-weight: 300;
    letter-spacing: 0.2em;
    text-transform: uppercase;
    color: var(--text-secondary);
    text-align: right;
    transition: color 0.6s ease, transform 0.6s ease;
    display: flex;
    align-items: center;
    justify-content: flex-end;
    gap: 8px;
  }

  .industry-label .dot {
    width: 4px;
    height: 4px;
    border-radius: 50%;
    background: var(--text-secondary);
    transition: all 0.6s ease;
    flex-shrink: 0;
  }

  .industry-label.active {
    color: var(--pulse-core);
    transform: translateX(-4px);
  }

  .industry-label.active .dot {
    background: var(--pulse-core);
    box-shadow: 0 0 8px var(--pulse-core);
  }

  .ladder-hint {
    position: absolute;
    bottom: 30px;
    left: 60px;
    font-size: 9px;
    font-weight: 300;
    letter-spacing: 0.15em;
    text-transform: uppercase;
    color: rgba(255, 58, 47, 0.3);
    opacity: 0;
    animation: fadeUp 1.8s cubic-bezier(0.16, 1, 0.3, 1) 2s forwards;
  }

  @keyframes fadeUp {
    from { opacity: 0; transform: translateY(20px); }
    to { opacity: 1; transform: translateY(0); }
  }

  /* Scan line effect */
  .scan-line {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 2px;
    background: linear-gradient(90deg, transparent, var(--pulse-core), transparent);
    opacity: 0.08;
    animation: scanDown 4s linear infinite;
    pointer-events: none;
    z-index: 5;
  }

  @keyframes scanDown {
    from { transform: translateY(-2px); }
    to { transform: translateY(100vh); }
  }
</style>
</head>
<body>

<canvas id="canvas"></canvas>

<div class="scan-line"></div>

<div class="overlay">
  <div class="corner-label tl">PLC</div>
  <div class="scan-counter" id="scanCounter">SCAN CYCLE 000000</div>

  <div class="title-block">
    <h1>One <em>Pulse.</em><br>Every System.</h1>
    <div class="subtitle">Programmable logic controlling the infrastructure of civilization</div>
  </div>

  <div class="industry-labels" id="industryLabels">
    <div class="industry-label" data-ring="1"><span>Energy Grid</span><span class="dot"></span></div>
    <div class="industry-label" data-ring="2"><span>Water Treatment</span><span class="dot"></span></div>
    <div class="industry-label" data-ring="3"><span>Manufacturing</span><span class="dot"></span></div>
    <div class="industry-label" data-ring="4"><span>Oil & Gas</span><span class="dot"></span></div>
    <div class="industry-label" data-ring="5"><span>Transport</span><span class="dot"></span></div>
    <div class="industry-label" data-ring="6"><span>Building Systems</span><span class="dot"></span></div>
    <div class="industry-label" data-ring="7"><span>Pharma</span><span class="dot"></span></div>
    <div class="industry-label" data-ring="8"><span>Food & Beverage</span><span class="dot"></span></div>
  </div>

  <div class="ladder-hint">← Click anywhere to trigger a scan cycle →</div>
</div>

<script>
// === CONFIGURATION ===
const CONFIG = {
  particleCount: 6000,
  ringCount: 8,
  pulseSpeed: 0.003,
  coreRadius: 30,
  ringSpacing: 55,
  particleBaseSize: 1.2,
  networkLineOpacity: 0.08,
  colors: {
    core: [255, 58, 47],
    mid: [255, 107, 53],
    outer: [26, 58, 92],
    cool: [40, 100, 180],
  }
};

// === CANVAS SETUP ===
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let W, H, cx, cy;
let scanCount = 0;
let mouseX = 0, mouseY = 0;
let time = 0;
let pulses = [];
let particles = [];
let networkNodes = [];

function resize() {
  W = canvas.width = window.innerWidth * devicePixelRatio;
  H = canvas.height = window.innerHeight * devicePixelRatio;
  cx = W / 2;
  cy = H / 2;
  canvas.style.width = window.innerWidth + 'px';
  canvas.style.height = window.innerHeight + 'px';
  ctx.scale(1, 1);
  initParticles();
  initNetworkNodes();
}

// === PARTICLES ===
function initParticles() {
  particles = [];
  for (let i = 0; i < CONFIG.particleCount; i++) {
    const ring = Math.floor(Math.random() * CONFIG.ringCount);
    const baseRadius = CONFIG.coreRadius + ring * CONFIG.ringSpacing;
    const angle = Math.random() * Math.PI * 2;
    const spread = CONFIG.ringSpacing * 0.4;
    const r = baseRadius + (Math.random() - 0.5) * spread;

    particles.push({
      ring,
      baseAngle: angle,
      angle,
      baseRadius: r,
      radius: r,
      size: CONFIG.particleBaseSize * (0.5 + Math.random() * 1.0),
      speed: (0.0002 + Math.random() * 0.0006) * (ring % 2 === 0 ? 1 : -1),
      brightness: 0.2 + Math.random() * 0.3,
      activeBrightness: 0,
      phase: Math.random() * Math.PI * 2,
      // Slight vertical offset for 3D illusion
      yOffset: (Math.random() - 0.5) * 30 * (1 + ring * 0.3),
    });
  }
}

// === NETWORK NODES (the "wiring" between rings) ===
function initNetworkNodes() {
  networkNodes = [];
  for (let ring = 0; ring < CONFIG.ringCount; ring++) {
    const count = 6 + ring * 2;
    for (let i = 0; i < count; i++) {
      const angle = (i / count) * Math.PI * 2;
      const r = CONFIG.coreRadius + ring * CONFIG.ringSpacing;
      networkNodes.push({ ring, angle, radius: r, active: 0 });
    }
  }
}

// === PULSE SYSTEM ===
function triggerPulse(x, y) {
  scanCount++;
  document.getElementById('scanCounter').textContent =
    `SCAN CYCLE ${String(scanCount).padStart(6, '0')}`;

  pulses.push({
    x: x * devicePixelRatio,
    y: y * devicePixelRatio,
    radius: 0,
    maxRadius: Math.max(W, H) * 0.8,
    speed: 3.5,
    life: 1.0,
    born: time,
  });
}

// Auto-pulse on load
setTimeout(() => triggerPulse(window.innerWidth / 2, window.innerHeight / 2), 800);
setInterval(() => {
  if (pulses.length < 2) {
    const angle = Math.random() * Math.PI * 2;
    const dist = 50 + Math.random() * 100;
    triggerPulse(
      window.innerWidth / 2 + Math.cos(angle) * dist,
      window.innerHeight / 2 + Math.sin(angle) * dist
    );
  }
}, 3500);

// === DRAWING HELPERS ===
function lerpColor(c1, c2, t) {
  return [
    c1[0] + (c2[0] - c1[0]) * t,
    c1[1] + (c2[1] - c1[1]) * t,
    c1[2] + (c2[2] - c1[2]) * t,
  ];
}

function getRingColor(ring, activation) {
  const ringT = ring / (CONFIG.ringCount - 1);
  const baseColor = lerpColor(CONFIG.colors.core, CONFIG.colors.cool, ringT);
  const activeColor = lerpColor(CONFIG.colors.core, CONFIG.colors.mid, ringT * 0.5);
  return lerpColor(baseColor, activeColor, activation);
}

// === DRAW RINGS (subtle orbital guides) ===
function drawRings() {
  for (let ring = 0; ring < CONFIG.ringCount; ring++) {
    const r = CONFIG.coreRadius + ring * CONFIG.ringSpacing;
    const ringT = ring / (CONFIG.ringCount - 1);

    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, Math.PI * 2);
    ctx.strokeStyle = `rgba(255, 58, 47, ${0.02 + ringT * 0.01})`;
    ctx.lineWidth = 0.5;
    ctx.stroke();
  }
}

// === DRAW NETWORK LINES ===
function drawNetwork() {
  for (let i = 0; i < networkNodes.length; i++) {
    const n = networkNodes[i];
    const x1 = cx + Math.cos(n.angle + time * 0.0003 * (n.ring % 2 === 0 ? 1 : -1)) * n.radius;
    const y1 = cy + Math.sin(n.angle + time * 0.0003 * (n.ring % 2 === 0 ? 1 : -1)) * n.radius;

    // Connect to nearby nodes in adjacent rings
    for (let j = i + 1; j < networkNodes.length; j++) {
      const m = networkNodes[j];
      if (Math.abs(m.ring - n.ring) !== 1) continue;

      const x2 = cx + Math.cos(m.angle + time * 0.0003 * (m.ring % 2 === 0 ? 1 : -1)) * m.radius;
      const y2 = cy + Math.sin(m.angle + time * 0.0003 * (m.ring % 2 === 0 ? 1 : -1)) * m.radius;

      const dist = Math.hypot(x2 - x1, y2 - y1);
      if (dist < CONFIG.ringSpacing * 1.8) {
        const activation = Math.max(n.active, m.active);
        const alpha = CONFIG.networkLineOpacity + activation * 0.15;
        const color = getRingColor(Math.min(n.ring, m.ring), activation);

        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.strokeStyle = `rgba(${color[0]|0}, ${color[1]|0}, ${color[2]|0}, ${alpha})`;
        ctx.lineWidth = 0.5 + activation * 1.5;
        ctx.stroke();
      }
    }
  }
}

// === DRAW CORE ===
function drawCore() {
  // Glowing core
  const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, CONFIG.coreRadius * 2.5);
  gradient.addColorStop(0, `rgba(255, 58, 47, 0.4)`);
  gradient.addColorStop(0.3, `rgba(255, 58, 47, 0.1)`);
  gradient.addColorStop(0.6, `rgba(255, 58, 47, 0.02)`);
  gradient.addColorStop(1, `rgba(255, 58, 47, 0)`);

  ctx.beginPath();
  ctx.arc(cx, cy, CONFIG.coreRadius * 2.5, 0, Math.PI * 2);
  ctx.fillStyle = gradient;
  ctx.fill();

  // Inner bright core
  const innerGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, CONFIG.coreRadius * 0.8);
  innerGrad.addColorStop(0, `rgba(255, 120, 80, 0.9)`);
  innerGrad.addColorStop(0.5, `rgba(255, 58, 47, 0.3)`);
  innerGrad.addColorStop(1, `rgba(255, 58, 47, 0)`);

  ctx.beginPath();
  ctx.arc(cx, cy, CONFIG.coreRadius * 0.8, 0, Math.PI * 2);
  ctx.fillStyle = innerGrad;
  ctx.fill();

  // Pulsing core dot
  const pulse = 0.8 + Math.sin(time * 0.005) * 0.2;
  ctx.beginPath();
  ctx.arc(cx, cy, 3 * pulse, 0, Math.PI * 2);
  ctx.fillStyle = `rgba(255, 200, 180, ${pulse})`;
  ctx.fill();
}

// === DRAW PARTICLES ===
function drawParticles() {
  for (const p of particles) {
    p.angle += p.speed;
    p.activeBrightness *= 0.97;

    // Check pulse activation
    for (const pulse of pulses) {
      const px = cx + Math.cos(p.angle) * p.radius;
      const py = cy + Math.sin(p.angle) * p.radius + p.yOffset;
      const dist = Math.hypot(px - pulse.x, py - pulse.y);
      const pulseDist = Math.abs(dist - pulse.radius);
      if (pulseDist < 40) {
        p.activeBrightness = Math.min(1, p.activeBrightness + 0.5 * pulse.life);
      }
    }

    const wobble = Math.sin(time * 0.002 + p.phase) * 3;
    const x = cx + Math.cos(p.angle) * (p.radius + wobble);
    const y = cy + Math.sin(p.angle) * (p.radius + wobble) + p.yOffset;

    const brightness = p.brightness + p.activeBrightness * 0.7;
    const color = getRingColor(p.ring, p.activeBrightness);
    const size = p.size * (1 + p.activeBrightness * 2);

    // Glow for active particles
    if (p.activeBrightness > 0.1) {
      ctx.beginPath();
      ctx.arc(x, y, size * 4, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(${color[0]|0}, ${color[1]|0}, ${color[2]|0}, ${p.activeBrightness * 0.15})`;
      ctx.fill();
    }

    ctx.beginPath();
    ctx.arc(x, y, size, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(${color[0]|0}, ${color[1]|0}, ${color[2]|0}, ${brightness})`;
    ctx.fill();
  }
}

// === DRAW PULSES ===
function drawPulses() {
  for (let i = pulses.length - 1; i >= 0; i--) {
    const p = pulses[i];
    p.radius += p.speed;
    p.life = Math.max(0, 1 - p.radius / p.maxRadius);

    if (p.life <= 0) {
      pulses.splice(i, 1);
      continue;
    }

    // Update industry labels
    const screenRadius = p.radius / devicePixelRatio;
    const labels = document.querySelectorAll('.industry-label');
    labels.forEach(label => {
      const ring = parseInt(label.dataset.ring);
      const ringRadius = (CONFIG.coreRadius + ring * CONFIG.ringSpacing) / devicePixelRatio;
      if (Math.abs(screenRadius - ringRadius) < 30) {
        label.classList.add('active');
        setTimeout(() => label.classList.remove('active'), 800);
      }
    });

    // Update network node activation
    for (const node of networkNodes) {
      const nx = cx + Math.cos(node.angle) * node.radius;
      const ny = cy + Math.sin(node.angle) * node.radius;
      const dist = Math.hypot(nx - p.x, ny - p.y);
      if (Math.abs(dist - p.radius) < 30) {
        node.active = Math.min(1, node.active + 0.4 * p.life);
      }
    }

    // Pulse ring
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
    ctx.strokeStyle = `rgba(255, 58, 47, ${p.life * 0.25})`;
    ctx.lineWidth = 2 + p.life * 3;
    ctx.stroke();

    // Secondary softer ring
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.radius * 0.95, 0, Math.PI * 2);
    ctx.strokeStyle = `rgba(255, 107, 53, ${p.life * 0.08})`;
    ctx.lineWidth = 8;
    ctx.stroke();
  }

  // Decay network activations
  for (const node of networkNodes) {
    node.active *= 0.97;
  }
}

// === DRAW LADDER LOGIC HINT (subtle background pattern) ===
function drawLadderPattern() {
  const alpha = 0.015;
  const spacing = 80;
  const railX1 = cx - 250;
  const railX2 = cx + 250;
  const startY = cy - 200;

  // Left rail
  ctx.beginPath();
  ctx.moveTo(railX1, startY);
  ctx.lineTo(railX1, startY + spacing * 5);
  ctx.strokeStyle = `rgba(255, 58, 47, ${alpha})`;
  ctx.lineWidth = 1;
  ctx.stroke();

  // Right rail
  ctx.beginPath();
  ctx.moveTo(railX2, startY);
  ctx.lineTo(railX2, startY + spacing * 5);
  ctx.strokeStyle = `rgba(255, 58, 47, ${alpha})`;
  ctx.stroke();

  // Rungs with animated contacts
  for (let i = 0; i < 5; i++) {
    const y = startY + i * spacing;
    const contactOpen = Math.sin(time * 0.003 + i * 1.2) > 0.3;

    ctx.beginPath();
    ctx.moveTo(railX1, y);
    if (contactOpen) {
      ctx.lineTo(railX1 + 200, y);
      ctx.moveTo(railX1 + 220, y - 10);
      ctx.lineTo(railX1 + 220, y);
      ctx.moveTo(railX1 + 240, y);
      ctx.lineTo(railX2, y);
    } else {
      ctx.lineTo(railX2, y);
    }
    ctx.strokeStyle = `rgba(255, 58, 47, ${alpha * (contactOpen ? 2 : 1)})`;
    ctx.lineWidth = 0.5;
    ctx.stroke();
  }
}

// === MOUSE INTERACTION ===
document.addEventListener('mousemove', (e) => {
  mouseX = e.clientX;
  mouseY = e.clientY;
});

document.addEventListener('click', (e) => {
  triggerPulse(e.clientX, e.clientY);
});

// === MAIN LOOP ===
function animate() {
  time++;
  ctx.clearRect(0, 0, W, H);

  // Subtle vignette
  const vignette = ctx.createRadialGradient(cx, cy, 0, cx, cy, Math.max(W, H) * 0.7);
  vignette.addColorStop(0, 'rgba(7, 8, 10, 0)');
  vignette.addColorStop(0.7, 'rgba(7, 8, 10, 0.3)');
  vignette.addColorStop(1, 'rgba(7, 8, 10, 0.85)');
  ctx.fillStyle = vignette;
  ctx.fillRect(0, 0, W, H);

  drawLadderPattern();
  drawRings();
  drawNetwork();
  drawParticles();
  drawCore();
  drawPulses();

  requestAnimationFrame(animate);
}

// === INIT ===
window.addEventListener('resize', resize);
resize();
animate();
</script>
</body>
</html>
